---
title: Como o React Diferencia uma Classe de uma Fun√ß√£o?
date: '2018-12-02'
spoiler: Falamos sobre classes, new, instanceof, cadeias de prototype e design de API.
---

Considere esse componente `Greeting` que √© definido como uma fun√ß√£o:

```jsx
function Greeting() {
  return <p>Hello</p>;
}
```

O React tamb√©m d√° suporte para definirmos ele como uma classe:

```jsx
class Greeting extends React.Component {
  render() {
    return <p>Hello</p>;
  }
}
```

(At√© [recentemente](https://reactjs.org/docs/hooks-intro.html)), essa era a √∫nica forma de usar funcionalidades como `state`

Quando queremos renderizar `<Greeting />` voc√™ n√£o se importa como ele √© definido:

```jsx
// Classe ou fun√ß√£o ‚Äî tanto faz.
<Greeting />
```

Mas o *React* se importa com a diferen√ßa!

Se `Greeting` √© uma fun√ß√£o, o React precisa invocar ela:

```jsx
// Seu c√≥digo
function Greeting() {
  return <p>Hello</p>;
}

// Dentro do React
const result = Greeting(props); // <p>Hello</p>
```

Mas se `Greeting` for uma classe, o React precisa instanciar ela com o operador `new` e *depois* invocar o m√©todo `render` na inst√¢ncia que foi criada:

```jsx
// Seu c√≥digo
class Greeting extends React.Component {
  render() {
    return <p>Hello</p>;
  }
}

// Dentro do React
const instance = new Greeting(props); // Greeting {}
const result = instance.render(); // <p>Hello</p>
```

Em ambos os casos o objetivo do React √© renderizar o n√≥ (nesse exemplo, `<p>Hello</p>`). Mas os passos exatos dependem em como `Greeting` foi definido.

**Ent√£o como o React sabe se algo √© uma classe ou uma fun√ß√£o?**

Assim como meu [artigo anterior](/why-do-we-write-super-props/), **voc√™ n√£o *precisa* saber sobre isso para ser produtivo com o React.** Eu n√£o sabia isso durante anos. Por favor n√£o transforme isso numa quest√£o de entrevista. Na verdade esse artigo √© mais sobre JavaScript do que sobre React.

Esse blog √© para o leitor curioso que deseja saber o *porqu√™* de o React trabalhar de certa forma. Voc√™ √© essa pessoa? Ent√£o vamos mergulhar juntos.

**Essa √© uma longa jornada. Fique firme. Esse artigo n√£o possui muitas informa√ß√µes sobre React, mas mas iremos verificar alguns aspectos sobre `new`, `this`, `class`, arrow functions, `prototype`, `__proto__`, `instanceof` e como essas coisas trabalham juntas em JavaScript. Felizmente voc√™ n√£o precisa pensar muito sobre isso quando voc√™ *utiliza* o React. Mas se voc√™ est√° implementando o React...**

(Se voc√™ quer realmente apenas saber a resposta, pule para o final.)

----

Primeiro, precisamos entender poruqe √© importante tratar fun√ß√µes e classes de forma diferente. Veja como usamos o operador `new` quando chamamos uma classe:

```jsx{5}
// Se Greeting √© uma fun√ß√£o
const result = Greeting(props); // <p>Hello</p>

// Se Greeting √© uma classe
const instance = new Greeting(props); // Greeting {}
const result = instance.render(); // <p>Hello</p>
```

Vamos ver o que o operador `new` faz no JavaScript.

---

Nos velhos tempos, o JavaScript n√£o possu√≠a classes. Contudo, voc√™ poderia criar um padr√£o semelhante √†s classes usando apenas fun√ß√µes. **Concretamente, voc√™ pode usar *qualquer* fun√ß√£o de forma parecida com um construtor de uma classe adicionando o `new` antes de sua chamada:**

```jsx
// Apenas uma fun√ß√£o
function Person(name) {
  this.name = name;
}

var fred = new Person('Fred'); // ‚úÖ Person {name: 'Fred'}
var george = Person('George'); // üî¥ N√£o ir√° funcionar
```

Voc√™ ainda pode escrever seu c√≥digo assim hoje! Experimente nas DevTools.

Se voc√™ chamou `Person('Fred')` **sem** o `new`, o `this` dentro dela iria apontar para algo global e seria in√∫til (por exemplo, `window` ou `undefined`). Ent√£o nosso c√≥digo iria quebrar ou fazer algo estranho como `window.name`.

Adicionando o `new` antes da chamada, n√≥s dizemos: "Hey JavaScript, eu sei que `Person` √© apenas uma fun√ß√£o, mas vamos fingir que ela √© algo parecido com um m√©todo construtor de uma classe. **Crie um objeto `{}` e aponte o `this` dentro da fun√ß√£o `Person` para esse objeto, dessa forma posso atribuir algo como `this.name`. Ent√£o retorne esse objeto para mim.**"

Isso √© o que o operador `new` faz.

```jsx
var fred = new Person('Fred'); // Mesmo objeto `this` dentro de `Person`
```

O operador `new` tamb√©m faz com que tudo que pusermos em `Person.prototype` esteja dispon√≠vel no objeto `fred`:

```jsx{4-6,9}
function Person(name) {
  this.name = name;
}
Person.prototype.sayHi = function() {
  alert('Hi, I am ' + this.name);
}

var fred = new Person('Fred');
fred.sayHi();
```

Isso era a forma como as pessoas simulavam classes em JavaScript antes de serem adicionadas diretamente.

---

O `new` j√° existe por um bom tempo no JavaScript. Por√©m, classes s√£o mais recente. Elas nos permitem reescrever o c√≥digo acima para corresponder √†s nossas inten√ß√µes de forma mais direta:

```jsx
class Person {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    alert('Hi, I am ' + this.name);
  }
}

let fred = new Person('Fred');
fred.sayHi();
```

*Captar as inten√ß√µes do desenvolvedor* √© algo importante no design de APIs e linguagens.

Se voc√™ escrever uma fun√ß√£o, o JavaScript n√£o sabe dizer se ela deve ser chamada como `alert()` ou se ela serve como um construtor como `new Person()`. Esquecer de especificar o `new` para uma fun√ß√£o como `Person` iria gerar um comportamento confuso.

**A sintaxe das Classes nos permitem dizer: "Isso n√£o √© apenas uma fun√ß√£o - √© uma classe e ela tem um construtor".** Se voc√™ esquecer o `new` ao chamar ela, o JavaScript ir√° emitir um erro:

```jsx
let fred = new Person('Fred');
// ‚úÖ  Se Person √© uma fun√ß√£o: funciona sem problemas
// ‚úÖ  Se Person √© uma classe: funciona sem problemas tamb√©m

let george = Person('George'); // We forgot `new`
// üò≥ Se Person √© uma fun√ß√£o como um construtor: comportamento confuso
// üî¥ Se Person √© uma classe: falha imediatamente
```

Isso nos ajuda a pegar erros antecipadamente ao inv√©s de esperar algum erro obscuro como `this.name` sendo tratado como `window.name` ao inv√©s de `george.name`.

Ent√£o isso quer dizer que o React deve colocar o operador `new` antes de chamar uma classe. Ele n√£o pode apenas chamar como uma fun√ß√£o comum, pois o JavaScript iria tratar como um erro!

```jsx
class Counter extends React.Component {
  render() {
    return <p>Hello</p>;
  }
}

// üî¥ O React n√£o pode fazer assim
const instance = Counter(props);
```

Isso traria problemas.

---

Antes de vermos como o React resolve isso, √© importante lembrar que a maioria das pessoas que utilizam o React usam compiladores como o Babel para compilar funcionalidades modernas como classes para navegadores mais antigos. Ent√£o devemos considerar esses compiladores em nosso design.

Nas primeiras vers√µes do Babel, classes poderiam ser chamadas sem o `new`. Por√©m, isso foi resolvido - criando um pouco de c√≥digo extra:

```jsx
function Person(name) {
  // Um resultado um pouco simplificado do Babel:
  if (!(this instanceof Person)) {
    throw new TypeError("Cannot call a class as a function");
  }
  // Nosso c√≥digo:
  this.name = name;
}

new Person('Fred'); // ‚úÖ Ok
Person('George');   // üî¥ N√£o pode chamar uma classe como uma fun√ß√£o
``` 

Voc√™ deve ter visto c√≥digo parecido com esse em seu `bundle`. Isso √© o que todas aquelas fun√ß√µes `_classCallCheck` fazem. (Voc√™ pode reduzir o tamanho do seu `bundle` ao optar por um "modo livre" sem nenhuma verifica√ß√£o, mas isso pode complicar sua transi√ß√£o eventual para classes nativas.)

---

Agora voc√™ deve entender um pouco da diferen√ßa entre chamar algo com ou sem o operador `new`:

|  | `new Person()` | `Person()` |
|---|---|---|
| `classe` | ‚úÖ `this` √© uma inst√¢ncia de `Person` | üî¥ `TypeError`
| `fun√ß√£o` | ‚úÖ `this` √© uma inst√¢ncia de `Person` | üò≥ `this` √© `window` ou `undefined` |

Esse √© o motivo pelo qual o React deve chamar seu componente corretamente. **Se seu componente √© definido como uma classe, o React precisa usar o `new` ao chamar ele.**

Ent√£o o React pode apenas checar se algo √© uma classe ou n√£o?

N√£o √© t√£o f√°cil! Mesmo que pud√©ssemos [diferenciar uma classe de uma fun√ß√£o em JavaScript](https://stackoverflow.com/questions/29093396/how-do-you-check-the-difference-between-an-ecmascript-6-class-and-function), isso ainda n√£o iria funcionar para classes processadas por ferramentas como o Babel. Para o navegador, elas s√£o apenas fun√ß√µes. Azar para o React.

---

Certo, ent√£o talvez o React poderia apenas usar o `new` em todas as chamadas? Infelizmente isso n√£o iria sempre funcionar.

Com fun√ß√µes comuns, chamar elas com o operador `new` iria dar a elas um objeto de inst√¢ncia como `this`. Isso √© o desejado para fun√ß√µes escritas como construtores (como nossa `Person` acima), mas seria confuso para componentes de fun√ß√£o:

```jsx
function Greeting() {
  // N√£o esperamos que `this` seja nenhum tipo de inst√¢ncia aqui
  return <p>Hello</p>;
}
```

Isso pode ser toler√°vel. Mas h√° duas *outras* raz√µes que matam essa ideia.

---

The first reason why always using `new` wouldn‚Äôt work is that for native arrow functions (not the ones compiled by Babel), calling with `new` throws an error:

```jsx
const Greeting = () => <p>Hello</p>;
new Greeting(); // üî¥ Greeting is not a constructor
```

This behavior is intentional and follows from the design of arrow functions. One of the main perks of arrow functions is that they *don‚Äôt* have their own `this` value ‚Äî instead, `this` is resolved from the closest regular function:

```jsx{2,6,7}
class Friends extends React.Component {
  render() {
    const friends = this.props.friends;
    return friends.map(friend =>
      <Friend
        // `this` is resolved from the `render` method
        size={this.props.size}
        name={friend.name}
        key={friend.id}
      />
    );
  }
}
```

Okay, so **arrow functions don‚Äôt have their own `this`.** But that means they would be entirely useless as constructors!

```jsx
const Person = (name) => {
  // üî¥ This wouldn‚Äôt make sense!
  this.name = name;
}
```

Therefore, **JavaScript disallows calling an arrow function with `new`.** If you do it, you probably made a mistake anyway, and it‚Äôs best to tell you early. This is similar to how JavaScript doesn‚Äôt let you call a class *without* `new`.

This is nice but it also foils our plan. React can‚Äôt just call `new` on everything because it would break arrow functions! We could try detecting arrow functions specifically by their lack of `prototype`, and not `new` just them:

```jsx
(() => {}).prototype // undefined
(function() {}).prototype // {constructor: f}
```

But this [wouldn‚Äôt work](https://github.com/facebook/react/issues/4599#issuecomment-136562930) for functions compiled with Babel. This might not be a big deal, but there is another reason that makes this approach a dead end.

---

Another reason we can‚Äôt always use `new` is that it would preclude React from supporting components that return strings or other primitive types.

```jsx
function Greeting() {
  return 'Hello';
}

Greeting(); // ‚úÖ 'Hello'
new Greeting(); // üò≥ Greeting¬†{}
```

This, again, has to do with the quirks of the [`new` operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new) design. As we saw earlier, `new` tells the JavaScript engine to create an object, make that object `this` inside the function, and later give us that object as a result of `new`.

However, JavaScript also allows a function called with `new` to *override* the return value of `new` by returning some other object. Presumably, this was considered useful for patterns like pooling where we want to reuse instances:

```jsx{1-2,7-8,17-18}
// Created lazily
var zeroVector = null;

function Vector(x, y) {
  if (x === 0 && y === 0) {
    if (zeroVector !== null) {
      // Reuse the same instance
      return zeroVector;
    }
    zeroVector = this;
  }
  this.x = x;
  this.y = y;
}

var a = new Vector(1, 1);
var b = new Vector(0, 0);
var c = new Vector(0, 0); // üò≤ b === c
```

However, `new` also *completely ignores* a function‚Äôs return value if it‚Äôs *not* an object. If you return a string or a number, it‚Äôs like there was no `return` at all.

```jsx
function Answer() {
  return 42;
}

Answer(); // ‚úÖ 42
new Answer(); // üò≥ Answer {}
```

There is just no way to read a primitive return value (like a number or a string) from a function when calling it with `new`. So if React always used `new`, it would be unable to add support components that return strings!

That‚Äôs unacceptable so we need to compromise.

---

What did we learn so far? React needs to call classes (including Babel output) *with* `new` but it needs to call regular functions or arrow functions (including Babel output) *without* `new`. And there is no reliable way to distinguish them.

**If we can‚Äôt solve a general problem, can we solve a more specific one?**

When you define a component as a class, you‚Äôll likely want to extend `React.Component` for built-in methods like `this.setState()`. **Rather than try to detect all classes, can we detect only `React.Component` descendants?**

Spoiler: this is exactly what React does.

---

Perhaps, the idiomatic way to check if `Greeting` is a React component class is by testing if `Greeting.prototype instanceof React.Component`:

```jsx
class A {}
class B extends A {}

console.log(B.prototype instanceof A); // true
```

I know what you‚Äôre thinking. What just happened here?! To answer this, we need to understand JavaScript prototypes.

You might be familiar with the ‚Äúprototype chain‚Äù. Every object in JavaScript might have a ‚Äúprototype‚Äù. When we write `fred.sayHi()` but `fred` object has no `sayHi` property, we look for `sayHi` property on `fred`‚Äôs prototype. If we don‚Äôt find it there, we look at the next prototype in the chain ‚Äî `fred`‚Äôs prototype‚Äôs prototype. And so on.

**Confusingly, the `prototype` property of a class or a function _does not_ point to the prototype of that value.** I‚Äôm not kidding.

```jsx
function Person() {}

console.log(Person.prototype); // ü§™ Not Person's prototype
console.log(Person.__proto__); // üò≥ Person's prototype
```

So the ‚Äúprototype chain‚Äù is more like `__proto__.__proto__.__proto__` than `prototype.prototype.prototype`. This took me years to get.

What‚Äôs the `prototype` property on a function or a class, then? **It‚Äôs the `__proto__` given to all objects `new`ed with that class or a function!**

```jsx{8}
function Person(name) {
  this.name = name;
}
Person.prototype.sayHi = function() {
  alert('Hi, I am ' + this.name);
}

var fred = new Person('Fred'); // Sets `fred.__proto__` to `Person.prototype`
```

And that `__proto__` chain is how JavaScript looks up properties:

```jsx
fred.sayHi();
// 1. Does fred have a sayHi property? No.
// 2. Does fred.__proto__ have a sayHi property? Yes. Call it!

fred.toString();
// 1. Does fred have a toString property? No.
// 2. Does fred.__proto__ have a toString property? No.
// 3. Does fred.__proto__.__proto__ have a toString property? Yes. Call it!
```

In practice, you should almost never need to touch `__proto__` from the code directly unless you‚Äôre debugging something related to the prototype chain. If you want to make stuff available on `fred.__proto__`, you‚Äôre supposed to put it on `Person.prototype`. At least that‚Äôs how it was originally designed.

The `__proto__` property wasn‚Äôt even supposed to be exposed by browsers at first because the prototype chain was considered an internal concept. But some browsers added `__proto__` and eventually it was begrudgingly standardized (but deprecated in favor of `Object.getPrototypeOf()`).

**And yet I still find it very confusing that a property called `prototype` does not give you a value‚Äôs prototype** (for example, `fred.prototype` is undefined because `fred` is not a function). Personally, I think this is the biggest reason even experienced developers tend to misunderstand JavaScript prototypes.

---

This is a long post, eh? I‚Äôd say we‚Äôre 80% there. Hang on.

We know that when we say `obj.foo`, JavaScript actually looks for `foo` in `obj`, `obj.__proto__`, `obj.__proto__.__proto__`, and so on.

With classes, you‚Äôre not exposed directly to this mechanism, but `extends` also works on top of the good old prototype chain. That‚Äôs how our React class instance gets access to methods like `setState`:

```jsx{1,9,13}
class Greeting extends React.Component {
  render() {
    return <p>Hello</p>;
  }
}

let c = new Greeting();
console.log(c.__proto__); // Greeting.prototype
console.log(c.__proto__.__proto__); // React.Component.prototype
console.log(c.__proto__.__proto__.__proto__); // Object.prototype

c.render();      // Found on c.__proto__ (Greeting.prototype)
c.setState();    // Found on c.__proto__.__proto__ (React.Component.prototype)
c.toString();    // Found on c.__proto__.__proto__.__proto__ (Object.prototype)
```

In other words, **when you use classes, an instance‚Äôs `__proto__` chain ‚Äúmirrors‚Äù the class hierarchy:**

```jsx
// `extends` chain
Greeting
  ‚Üí React.Component
    ‚Üí Object (implicitly)

// `__proto__` chain
new Greeting()
  ‚Üí Greeting.prototype
    ‚Üí React.Component.prototype
      ‚Üí Object.prototype
```

2 Chainz.

---

Since the `__proto__` chain mirrors the class hierarchy, we can check whether a `Greeting` extends `React.Component` by starting with `Greeting.prototype`, and then following down its `__proto__` chain:

```jsx{3,4}
// `__proto__` chain
new Greeting()
  ‚Üí Greeting.prototype // üïµÔ∏è We start here
    ‚Üí React.Component.prototype // ‚úÖ Found it!
      ‚Üí Object.prototype
```

Conveniently, `x instanceof Y` does exactly this kind of search. It follows the `x.__proto__` chain looking for `Y.prototype` there.

Normally, it‚Äôs used to determine whether something is an instance of a class:

```jsx
let greeting = new Greeting();

console.log(greeting instanceof Greeting); // true
// greeting (üïµÔ∏è‚Äç We start here)
//   .__proto__ ‚Üí Greeting.prototype (‚úÖ Found it!)
//     .__proto__ ‚Üí React.Component.prototype 
//       .__proto__ ‚Üí Object.prototype

console.log(greeting instanceof React.Component); // true
// greeting (üïµÔ∏è‚Äç We start here)
//   .__proto__ ‚Üí Greeting.prototype
//     .__proto__ ‚Üí React.Component.prototype (‚úÖ Found it!)
//       .__proto__ ‚Üí Object.prototype

console.log(greeting instanceof Object); // true
// greeting (üïµÔ∏è‚Äç We start here)
//   .__proto__ ‚Üí Greeting.prototype
//     .__proto__ ‚Üí React.Component.prototype
//       .__proto__ ‚Üí Object.prototype (‚úÖ Found it!)

console.log(greeting instanceof Banana); // false
// greeting (üïµÔ∏è‚Äç We start here)
//   .__proto__ ‚Üí Greeting.prototype
//     .__proto__ ‚Üí React.Component.prototype 
//       .__proto__ ‚Üí Object.prototype (üôÖ‚Äç Did not find it!)
```

But it would work just as fine to determine if a class extends another class:

```jsx
console.log(Greeting.prototype instanceof React.Component);
// greeting
//   .__proto__ ‚Üí Greeting.prototype (üïµÔ∏è‚Äç We start here)
//     .__proto__ ‚Üí React.Component.prototype (‚úÖ Found it!)
//       .__proto__ ‚Üí Object.prototype
```

And that check is how we could determine if something is a React component class or a regular function.

---

That‚Äôs not what React does though. üò≥

One caveat to the `instanceof` solution is that it doesn‚Äôt work when there are multiple copies of React on the page, and the component we‚Äôre checking inherits from *another* React copy‚Äôs `React.Component`. Mixing multiple copies of React in a single project is bad for several reasons but historically we‚Äôve tried to avoid issues when possible. (With Hooks, we [might need to](https://github.com/facebook/react/issues/13991) force deduplication though.)

One other possible heuristic could be to check for presence of a `render` method on the prototype. However, at the time it [wasn‚Äôt clear](https://github.com/facebook/react/issues/4599#issuecomment-129714112) how the component API would evolve. Every check has a cost so we wouldn‚Äôt want to add more than one. This would also not work if `render` was defined as an instance method, such as with the class property syntax.

So instead, React [added](https://github.com/facebook/react/pull/4663) a special flag to the base component. React checks for the presence of that flag, and that‚Äôs how it knows whether something is a React component class or not.

Originally the flag was on the base `React.Component` class itself:

```jsx
// Inside React
class Component {}
Component.isReactClass = {};

// We can check it like this
class Greeting extends Component {}
console.log(Greeting.isReactClass); // ‚úÖ Yes
```

However, some class implementations we wanted to target [did not](https://github.com/scala-js/scala-js/issues/1900) copy static properties (or set the non-standard `__proto__`), so the flag was getting lost.

This is why React [moved](https://github.com/facebook/react/pull/5021) this flag to `React.Component.prototype`: 

```jsx
// Inside React
class Component {}
Component.prototype.isReactComponent = {};

// We can check it like this
class Greeting extends Component {}
console.log(Greeting.prototype.isReactComponent); // ‚úÖ Yes
```

**And this is literally all there is to it.**

You might be wondering why it‚Äôs an object and not just a boolean. It doesn‚Äôt matter much in practice but early versions of Jest (before Jest was Good‚Ñ¢Ô∏è) had automocking turned on by default. The generated mocks omitted primitive properties, [breaking the check](https://github.com/facebook/react/pull/4663#issuecomment-136533373). Thanks, Jest.

The `isReactComponent` check is [used in React](https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js#L297-L300) to this day.

If you don‚Äôt extend `React.Component`, React won‚Äôt find `isReactComponent` on the prototype, and won‚Äôt treat component as a class. Now you know why [the most upvoted answer](https://stackoverflow.com/a/42680526/458193) for `Cannot call a class as a function` error is to add `extends React.Component`. Finally, a [warning was added](https://github.com/facebook/react/pull/11168) that warns when `prototype.render` exists but `prototype.isReactComponent` doesn‚Äôt.

---

You might say this story is a bit of a bait-and-switch. **The actual solution is really simple, but I went on a huge tangent to explain *why* React ended up with this solution, and what the alternatives were.**

In my experience, that‚Äôs often the case with library APIs. For an API to be simple to use, you often need to consider the language semantics (possibly, for several languages, including future directions), runtime performance, ergonomics with and without compile-time steps, the state of the ecosystem and packaging solutions, early warnings, and many other things. The end result might not always be the most elegant, but it must be practical.

**If the final API is successful, _its users_ never have to think about this process.** Instead they can focus on creating apps.

But if you‚Äôre also curious... it‚Äôs nice to know how it works.
